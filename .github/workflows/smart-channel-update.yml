name: Smart Channel Update with Stream Validation

on:
  workflow_dispatch:
    inputs:
      primary_url:
        description: 'Primary M3U source URL'
        required: true
        type: string
      backup_url:
        description: 'Backup M3U source URL'
        required: false
        type: string
        default: 'https://streaming.televizor-24-tochka.ru/playlist.m3u8'
      force_backup:
        description: 'Force use backup source'
        required: false
        type: boolean
        default: false
  schedule:
    # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∂–¥—ã–µ 30 –º–∏–Ω—É—Ç
    - cron: '*/30 * * * *'

jobs:
  smart-update:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        run: |
          npm install axios

      - name: Simple Channel Update with Backup
        run: |
          # –°–æ–∑–¥–∞–µ–º —É–º–Ω—ã–π —Å–∫—Ä–∏–ø—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫–∞–Ω–∞–ª–æ–≤
          cat > smart_update.js << 'EOF'
          const fs = require('fs');
          const https = require('https');
          const http = require('http');
          const { URL } = require('url');

          // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
          const PRIMARY_URL = process.env.PRIMARY_URL || '${{ github.event.inputs.primary_url }}';
          const BACKUP_URL = process.env.BACKUP_URL || '${{ github.event.inputs.backup_url }}';
          const FORCE_BACKUP = process.env.FORCE_BACKUP === 'true' || '${{ github.event.inputs.force_backup }}' === 'true';
          
          console.log('üîÑ –ü—Ä–æ—Å—Ç–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–Ω–∞–ª–æ–≤ —Å —Ä–µ–∑–µ—Ä–≤–æ–º...');
          console.log(`üì° –û—Å–Ω–æ–≤–Ω–æ–π –∏—Å—Ç–æ—á–Ω–∏–∫: ${PRIMARY_URL || '–Ω–µ —É–∫–∞–∑–∞–Ω'}`);
          console.log(`üîÑ –†–µ–∑–µ—Ä–≤–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫: ${BACKUP_URL}`);
          console.log(`üéØ –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Ä–µ–∑–µ—Ä–≤–∞: ${FORCE_BACKUP}`);

          // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –ø–æ URL
          async function fetchContent(url) {
            return new Promise((resolve, reject) => {
              const client = url.startsWith('https') ? https : http;
              const request = client.get(url, { timeout: 15000 }, (response) => {
                if (response.statusCode !== 200) {
                  reject(new Error(`HTTP ${response.statusCode}: ${response.statusMessage}`));
                  return;
                }
                
                let data = '';
                response.on('data', chunk => data += chunk);
                response.on('end', () => resolve(data));
              });
              
              request.on('timeout', () => {
                request.destroy();
                reject(new Error('Request timeout'));
              });
              
              request.on('error', reject);
            });
          }

          // –ü—Ä–æ—Å—Ç–∞—è —Ñ—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫–∞–Ω–∞–ª–æ–≤ (–∫–∞–∫ –≤ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–º —Ä–µ–∂–∏–º–µ)
          function updateChannelUrls(currentChannels, sourceChannels) {
            let updated = 0;
            const updatedChannels = [...currentChannels];
            
            for (let i = 0; i < updatedChannels.length; i++) {
              const current = updatedChannels[i];
              
              // –ò—â–µ–º —Ç–æ—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –ø–æ EXTINF —Å—Ç—Ä–æ–∫–µ
              const match = sourceChannels.find(source => source.extinf === current.extinf);
              
              if (match && current.url !== match.url) {
                console.log(`‚úÖ –û–±–Ω–æ–≤–ª–µ–Ω: ${current.name}`);
                console.log(`   –°—Ç–∞—Ä—ã–π URL: ${current.url}`);
                console.log(`   –ù–æ–≤—ã–π URL: ${match.url}`);
                updatedChannels[i].url = match.url;
                updated++;
              } else if (match) {
                console.log(`‚ÑπÔ∏è URL –¥–ª—è "${current.name}" –Ω–µ –∏–∑–º–µ–Ω–∏–ª—Å—è`);
              } else {
                console.log(`‚ö†Ô∏è –°–æ–≤–ø–∞–¥–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –¥–ª—è: ${current.name}`);
              }
            }
            
            return { channels: updatedChannels, updated };
          }

          // –§—É–Ω–∫—Ü–∏—è –ø–∞—Ä—Å–∏–Ω–≥–∞ M3U —Ñ–∞–π–ª–∞
          function parseM3U(content) {
            const lines = content.split('\n').map(line => line.trim()).filter(line => line);
            const channels = [];
            
            for (let i = 0; i < lines.length; i++) {
              if (lines[i].startsWith('#EXTINF')) {
                const extinf = lines[i];
                const name = extinf.split(',').pop().trim();
                const nextLine = lines[i + 1];
                
                if (nextLine && !nextLine.startsWith('#')) {
                  channels.push({
                    extinf: extinf,
                    name: name,
                    url: nextLine
                  });
                  i++; // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–ª–µ–¥—É—é—â—É—é —Å—Ç—Ä–æ–∫—É
                }
              }
            }
            
            return channels;
          }



          // –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è M3U –∫–æ–Ω—Ç–µ–Ω—Ç–∞
          function createM3U(channels) {
            let content = '#EXTM3U\n';
            for (const channel of channels) {
              content += `${channel.extinf}\n${channel.url}\n\n`;
            }
            return content;
          }

          // –§—É–Ω–∫—Ü–∏—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –¥–æ–º–µ–Ω–æ–≤ –∏–∑ –∫–∞–Ω–∞–ª–æ–≤
          function extractDomains(channels) {
            const domains = new Set();
            for (const channel of channels) {
              try {
                const url = new URL(channel.url);
                const hostname = url.hostname;
                if (hostname && !hostname.includes('localhost') && !hostname.includes('127.0.0.1')) {
                  domains.add(hostname);
                }
              } catch (e) {
                // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –Ω–µ–≤–∞–ª–∏–¥–Ω—ã–µ URL
              }
            }
            return Array.from(domains);
          }

          // –ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è (–ø—Ä–æ—Å—Ç–∞—è –ª–æ–≥–∏–∫–∞)
          async function main() {
            try {
              // –ó–∞–≥—Ä—É–∂–∞–µ–º —Ç–µ–∫—É—â–∏–π —Å–ø–∏—Å–æ–∫ –∫–∞–Ω–∞–ª–æ–≤
              console.log('üì• –ó–∞–≥—Ä—É–∂–∞–µ–º —Ç–µ–∫—É—â–∏–π —Å–ø–∏—Å–æ–∫ –∫–∞–Ω–∞–ª–æ–≤...');
              const currentContent = fs.readFileSync('files/channels.m3u8', 'utf8');
              const currentChannels = parseM3U(currentContent);
              console.log(`üìä –ó–∞–≥—Ä—É–∂–µ–Ω–æ ${currentChannels.length} —Ç–µ–∫—É—â–∏—Ö –∫–∞–Ω–∞–ª–æ–≤`);

              let result = null;
              let sourceUsed = '';

              // –ü—Ä–æ–±—É–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π –∏—Å—Ç–æ—á–Ω–∏–∫ (–µ—Å–ª–∏ –Ω–µ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω—ã–π —Ä–µ–∑–µ—Ä–≤)
              if (!FORCE_BACKUP && PRIMARY_URL) {
                try {
                  console.log('\nüì° –ü—Ä–æ–±—É–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π –∏—Å—Ç–æ—á–Ω–∏–∫...');
                  const primaryContent = await fetchContent(PRIMARY_URL);
                  const primaryChannels = parseM3U(primaryContent);
                  
                  result = updateChannelUrls(currentChannels, primaryChannels);
                  sourceUsed = '–û—Å–Ω–æ–≤–Ω–æ–π';
                  console.log(`‚úÖ –û—Å–Ω–æ–≤–Ω–æ–π –∏—Å—Ç–æ—á–Ω–∏–∫ –æ–±—Ä–∞–±–æ—Ç–∞–Ω: ${result.updated} –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π`);
                } catch (error) {
                  console.log(`‚ùå –û—à–∏–±–∫–∞ —Å –æ—Å–Ω–æ–≤–Ω—ã–º –∏—Å—Ç–æ—á–Ω–∏–∫–æ–º: ${error.message}`);
                }
              }

              // –ï—Å–ª–∏ –æ—Å–Ω–æ–≤–Ω–æ–π –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª –∏–ª–∏ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω—ã–π —Ä–µ–∑–µ—Ä–≤, –ø—Ä–æ–±—É–µ–º —Ä–µ–∑–µ—Ä–≤–Ω—ã–π
              if ((!result || result.updated === 0) && BACKUP_URL) {
                try {
                  console.log('\nüîÑ –ü—Ä–æ–±—É–µ–º —Ä–µ–∑–µ—Ä–≤–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫...');
                  const backupContent = await fetchContent(BACKUP_URL);
                  const backupChannels = parseM3U(backupContent);
                  
                  result = updateChannelUrls(currentChannels, backupChannels);
                  sourceUsed = '–†–µ–∑–µ—Ä–≤–Ω—ã–π';
                  console.log(`‚úÖ –†–µ–∑–µ—Ä–≤–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫ –æ–±—Ä–∞–±–æ—Ç–∞–Ω: ${result.updated} –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π`);
                } catch (error) {
                  console.log(`‚ùå –û—à–∏–±–∫–∞ —Å —Ä–µ–∑–µ—Ä–≤–Ω—ã–º –∏—Å—Ç–æ—á–Ω–∏–∫–æ–º: ${error.message}`);
                }
              }

              // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
              if (result && result.updated > 0) {
                const newContent = createM3U(result.channels);
                fs.writeFileSync('files/channels.m3u8', newContent);
                
                console.log(`\nüéâ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!`);
                console.log(`üìä –ò—Å—Ç–æ—á–Ω–∏–∫: ${sourceUsed}`);
                console.log(`üîÑ –û–±–Ω–æ–≤–ª–µ–Ω–æ –∫–∞–Ω–∞–ª–æ–≤: ${result.updated}`);
                console.log(`üì∫ –í—Å–µ–≥–æ –∫–∞–Ω–∞–ª–æ–≤: ${result.channels.length}`);
                
                // –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–æ–º–µ–Ω—ã –¥–ª—è security config
                const domains = extractDomains(result.channels);
                fs.writeFileSync('extracted_domains.txt', domains.join('\n'));
                
                console.log(`üîí –ò–∑–≤–ª–µ—á–µ–Ω–æ –¥–æ–º–µ–Ω–æ–≤: ${domains.length}`);
                console.log(`UPDATED_COUNT=${result.updated}`);
                
                process.exit(0);
              } else {
                console.log('\n‚ùå –ù–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π –∏–ª–∏ –æ—à–∏–±–∫–∞');
                console.log('UPDATED_COUNT=0');
                process.exit(1);
              }
              
            } catch (error) {
              console.error(`‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: ${error.message}`);
              console.log('UPDATED_COUNT=0');
              process.exit(1);
            }
          }

          main();
          EOF

          # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –¥–ª—è —Å–∫—Ä–∏–ø—Ç–∞
          export PRIMARY_URL="${{ github.event.inputs.primary_url }}"
          export BACKUP_URL="${{ github.event.inputs.backup_url }}"
          export FORCE_BACKUP="${{ github.event.inputs.force_backup }}"
          
          # –ó–∞–ø—É—Å–∫–∞–µ–º —É–º–Ω—ã–π —Å–∫—Ä–∏–ø—Ç
          if node smart_update.js > update_output.txt 2>&1; then
            UPDATED_COUNT=$(grep "UPDATED_COUNT=" update_output.txt | cut -d'=' -f2)
            echo "updated_count=${UPDATED_COUNT}" >> $GITHUB_OUTPUT
            echo "has_changes=true" >> $GITHUB_OUTPUT
            cat update_output.txt
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "updated_count=0" >> $GITHUB_OUTPUT
            cat update_output.txt
          fi

      - name: Auto-update security domains
        if: steps.smart-update.outputs.has_changes == 'true'
        run: |
          echo "üîí –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–æ–º–µ–Ω–æ–≤ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏..."
          
          if [ -f "extracted_domains.txt" ]; then
            # –ß–∏—Ç–∞–µ–º –∏–∑–≤–ª–µ—á–µ–Ω–Ω—ã–µ –¥–æ–º–µ–Ω—ã
            NEW_DOMAINS=$(cat extracted_domains.txt)
            echo "üì° –ù–∞–π–¥–µ–Ω–Ω—ã–µ –¥–æ–º–µ–Ω—ã: $NEW_DOMAINS"
            
            # –ß–∏—Ç–∞–µ–º —Ç–µ–∫—É—â–∏–π security config
            CURRENT_XML=$(cat files/security_config.xml)
            
            # –ò–∑–≤–ª–µ–∫–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –¥–æ–º–µ–Ω—ã
            EXISTING_DOMAINS=$(echo "$CURRENT_XML" | grep -o '<domain[^>]*>[^<]*</domain>' | sed 's/<domain[^>]*>//g' | sed 's/<\/domain>//g' | sort | uniq)
            
            # –û–±—ä–µ–¥–∏–Ω—è–µ–º –¥–æ–º–µ–Ω—ã
            ALL_DOMAINS=$(echo -e "$EXISTING_DOMAINS\n$NEW_DOMAINS" | sort | uniq | grep -v "^$")
            
            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã–π security config
            cat > files/security_config.xml << 'SECURITY_EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <network-security-config>
              <domain-config cleartextTrafficPermitted="true">
          SECURITY_EOF
            
            # –î–æ–±–∞–≤–ª—è–µ–º –¥–æ–º–µ–Ω—ã
            echo "$ALL_DOMAINS" | while read domain; do
              if [ ! -z "$domain" ]; then
                echo "        <domain>$domain</domain>" >> files/security_config.xml
              fi
            done
            
            cat >> files/security_config.xml << 'SECURITY_EOF'
              </domain-config>
          </network-security-config>
          SECURITY_EOF
            
            echo "‚úÖ Security config –æ–±–Ω–æ–≤–ª–µ–Ω —Å $(echo "$ALL_DOMAINS" | wc -l) –¥–æ–º–µ–Ω–∞–º–∏"
          else
            echo "‚ö†Ô∏è –§–∞–π–ª extracted_domains.txt –Ω–µ –Ω–∞–π–¥–µ–Ω"
          fi

      - name: Commit changes
        if: steps.smart-update.outputs.has_changes == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "Smart Channel Updater"
          
          # –î–æ–±–∞–≤–ª—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è
          git add files/channels.m3u8 files/security_config.xml
          
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è
          if git diff --staged --quiet; then
            echo "–ù–µ—Ç –∏–∑–º–µ–Ω–µ–Ω–∏–π –¥–ª—è –∫–æ–º–º–∏—Ç–∞"
          else
            UPDATED_COUNT="${{ steps.smart-update.outputs.updated_count }}"
            git commit -m "ü§ñ Smart update: $UPDATED_COUNT channels updated with stream validation

            - –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–±–æ—Ç–æ—Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ –ø–æ—Ç–æ–∫–æ–≤
            - –£–º–Ω–æ–µ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –º–µ–∂–¥—É –∏—Å—Ç–æ—á–Ω–∏–∫–∞–º–∏
            - –ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–æ–º–µ–Ω–æ–≤ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
            - Quality score: –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ $UPDATED_COUNT –∫–∞–Ω–∞–ª–æ–≤"
            git push
            echo "‚úÖ –ò–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π"
          fi

      - name: Cleanup
        run: |
          rm -f smart_update.js update_output.txt extracted_domains.txt
