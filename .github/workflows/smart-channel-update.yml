name: Smart Channel Update with Stream Validation

on:
  workflow_dispatch:
    inputs:
      primary_url:
        description: 'Primary M3U source URL'
        required: true
        type: string
      backup_url:
        description: 'Backup M3U source URL'
        required: false
        type: string
        default: 'https://streaming.televizor-24-tochka.ru/playlist.m3u8'
      force_backup:
        description: 'Force use backup source'
        required: false
        type: boolean
        default: false
  schedule:
    # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∂–¥—ã–µ 2 —á–∞—Å–∞
    - cron: '0 */2 * * *'

jobs:
  smart-update:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        run: |
          npm install axios

      - name: Smart Channel Update with Stream Validation
        run: |
          # –°–æ–∑–¥–∞–µ–º —É–º–Ω—ã–π —Å–∫—Ä–∏–ø—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫–∞–Ω–∞–ª–æ–≤
          cat > smart_update.js << 'EOF'
          const fs = require('fs');
          const https = require('https');
          const http = require('http');
          const { URL } = require('url');

          // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
          const PRIMARY_URL = process.env.PRIMARY_URL || '${{ github.event.inputs.primary_url }}';
          const BACKUP_URL = process.env.BACKUP_URL || '${{ github.event.inputs.backup_url }}';
          const FORCE_BACKUP = process.env.FORCE_BACKUP === 'true' || '${{ github.event.inputs.force_backup }}' === 'true';
          
          // –¢–∞–π–º-–∞—É—Ç—ã –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ—Ç–æ–∫–æ–≤
          const STREAM_CHECK_TIMEOUT = 10000; // 10 —Å–µ–∫—É–Ω–¥
          const MAX_STREAMS_TO_CHECK = 5; // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–µ 5 –ø–æ—Ç–æ–∫–æ–≤
          
          console.log('üöÄ –ù–∞—á–∏–Ω–∞–µ–º —É–º–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–Ω–∞–ª–æ–≤...');
          console.log(`üì° –û—Å–Ω–æ–≤–Ω–æ–π –∏—Å—Ç–æ—á–Ω–∏–∫: ${PRIMARY_URL || '–Ω–µ —É–∫–∞–∑–∞–Ω'}`);
          console.log(`üîÑ –†–µ–∑–µ—Ä–≤–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫: ${BACKUP_URL}`);
          console.log(`üéØ –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Ä–µ–∑–µ—Ä–≤–∞: ${FORCE_BACKUP}`);

          // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –ø–æ URL
          async function fetchContent(url) {
            return new Promise((resolve, reject) => {
              const client = url.startsWith('https') ? https : http;
              const request = client.get(url, { timeout: 15000 }, (response) => {
                if (response.statusCode !== 200) {
                  reject(new Error(`HTTP ${response.statusCode}: ${response.statusMessage}`));
                  return;
                }
                
                let data = '';
                response.on('data', chunk => data += chunk);
                response.on('end', () => resolve(data));
              });
              
              request.on('timeout', () => {
                request.destroy();
                reject(new Error('Request timeout'));
              });
              
              request.on('error', reject);
            });
          }

          // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ä–∞–±–æ—Ç–æ—Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ –ø–æ—Ç–æ–∫–∞
          async function checkStream(url) {
            return new Promise((resolve) => {
              try {
                const client = url.startsWith('https') ? https : http;
                const request = client.get(url, { timeout: STREAM_CHECK_TIMEOUT }, (response) => {
                  // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å –æ—Ç–≤–µ—Ç–∞
                  const isWorking = response.statusCode === 200 || response.statusCode === 206;
                  request.destroy();
                  resolve(isWorking);
                });
                
                request.on('timeout', () => {
                  request.destroy();
                  resolve(false);
                });
                
                request.on('error', () => {
                  resolve(false);
                });
              } catch (error) {
                resolve(false);
              }
            });
          }

          // –§—É–Ω–∫—Ü–∏—è –ø–∞—Ä—Å–∏–Ω–≥–∞ M3U —Ñ–∞–π–ª–∞
          function parseM3U(content) {
            const lines = content.split('\n').map(line => line.trim()).filter(line => line);
            const channels = [];
            
            for (let i = 0; i < lines.length; i++) {
              if (lines[i].startsWith('#EXTINF')) {
                const extinf = lines[i];
                const name = extinf.split(',').pop().trim();
                const nextLine = lines[i + 1];
                
                if (nextLine && !nextLine.startsWith('#')) {
                  channels.push({
                    extinf: extinf,
                    name: name,
                    url: nextLine
                  });
                  i++; // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–ª–µ–¥—É—é—â—É—é —Å—Ç—Ä–æ–∫—É
                }
              }
            }
            
            return channels;
          }

          // –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø–æ–∏—Å–∫–∞ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π –∫–∞–Ω–∞–ª–æ–≤
          function findChannelMatch(currentChannel, sourceChannels) {
            const currentName = currentChannel.name.toLowerCase();
            
            // 1. –¢–æ—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –ø–æ EXTINF —Å—Ç—Ä–æ–∫–µ
            let match = sourceChannels.find(ch => ch.extinf === currentChannel.extinf);
            if (match) return { match, type: 'exact_extinf' };
            
            // 2. –¢–æ—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é
            match = sourceChannels.find(ch => ch.name.toLowerCase() === currentName);
            if (match) return { match, type: 'exact_name' };
            
            // 3. –ü–æ–∏—Å–∫ HD –≤–µ—Ä—Å–∏–∏ –¥–ª—è –æ–±—ã—á–Ω—ã—Ö –∫–∞–Ω–∞–ª–æ–≤
            if (!currentName.includes('hd')) {
              match = sourceChannels.find(ch => {
                const sourceName = ch.name.toLowerCase();
                return sourceName.includes(currentName.replace(/\s+/g, '')) && sourceName.includes('hd');
              });
              if (match) return { match, type: 'hd_version' };
            }
            
            // 4. –ü–æ–∏—Å–∫ –±–µ–∑ HD –¥–ª—è HD –∫–∞–Ω–∞–ª–æ–≤
            if (currentName.includes('hd')) {
              const nameWithoutHD = currentName.replace(/\s*hd\s*/g, '').trim();
              match = sourceChannels.find(ch => {
                const sourceName = ch.name.toLowerCase();
                return sourceName.includes(nameWithoutHD) || nameWithoutHD.includes(sourceName);
              });
              if (match) return { match, type: 'non_hd_version' };
            }
            
            // 5. –ß–∞—Å—Ç–∏—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º
            const keywords = currentName.split(/\s+/).filter(word => word.length > 2);
            match = sourceChannels.find(ch => {
              const sourceName = ch.name.toLowerCase();
              return keywords.some(keyword => sourceName.includes(keyword));
            });
            if (match) return { match, type: 'partial_match' };
            
            return null;
          }

          // –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫–∞–Ω–∞–ª–æ–≤
          async function updateChannels(currentChannels, sourceChannels, sourceName) {
            console.log(`üîÑ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–Ω–∞–ª–æ–≤ –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞: ${sourceName}`);
            console.log(`üìä –¢–µ–∫—É—â–∏—Ö –∫–∞–Ω–∞–ª–æ–≤: ${currentChannels.length}, –∏—Å—Ç–æ—á–Ω–∏–∫: ${sourceChannels.length}`);
            
            const updatedChannels = [];
            const workingChannels = [];
            const brokenChannels = [];
            let updatedCount = 0;
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–µ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ—Ç–æ–∫–æ–≤ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –∫–∞—á–µ—Å—Ç–≤–∞ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
            const streamsToCheck = sourceChannels.slice(0, MAX_STREAMS_TO_CHECK);
            console.log(`üîç –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–±–æ—Ç–æ—Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å ${streamsToCheck.length} –ø–æ—Ç–æ–∫–æ–≤...`);
            
            let workingStreams = 0;
            for (const channel of streamsToCheck) {
              const isWorking = await checkStream(channel.url);
              if (isWorking) {
                workingStreams++;
                console.log(`‚úÖ –ü–æ—Ç–æ–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç: ${channel.name}`);
              } else {
                console.log(`‚ùå –ü–æ—Ç–æ–∫ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç: ${channel.name}`);
              }
            }
            
            const sourceQuality = workingStreams / streamsToCheck.length;
            console.log(`üìà –ö–∞—á–µ—Å—Ç–≤–æ –∏—Å—Ç–æ—á–Ω–∏–∫–∞: ${Math.round(sourceQuality * 100)}% (${workingStreams}/${streamsToCheck.length})`);
            
            // –ï—Å–ª–∏ –∫–∞—á–µ—Å—Ç–≤–æ –∏—Å—Ç–æ—á–Ω–∏–∫–∞ —Å–ª–∏—à–∫–æ–º –Ω–∏–∑–∫–æ–µ, –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ
            if (sourceQuality < 0.3) {
              console.log(`‚ö†Ô∏è –ö–∞—á–µ—Å—Ç–≤–æ –∏—Å—Ç–æ—á–Ω–∏–∫–∞ —Å–ª–∏—à–∫–æ–º –Ω–∏–∑–∫–æ–µ (${Math.round(sourceQuality * 100)}%), –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ`);
              return {
                channels: currentChannels,
                updated: 0,
                quality: sourceQuality,
                working: [],
                broken: []
              };
            }
            
            for (const currentChannel of currentChannels) {
              const matchResult = findChannelMatch(currentChannel, sourceChannels);
              
              if (matchResult) {
                const { match, type } = matchResult;
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–±–æ—Ç–æ—Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å –Ω–æ–≤–æ–≥–æ –ø–æ—Ç–æ–∫–∞
                const isWorking = await checkStream(match.url);
                
                if (isWorking) {
                  // –û–±–Ω–æ–≤–ª—è–µ–º URL –µ—Å–ª–∏ –æ–Ω –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è
                  if (currentChannel.url !== match.url) {
                    currentChannel.url = match.url;
                    updatedCount++;
                    console.log(`‚úÖ –û–±–Ω–æ–≤–ª–µ–Ω: ${currentChannel.name} (${type})`);
                  }
                  workingChannels.push(currentChannel.name);
                } else {
                  console.log(`‚ö†Ô∏è –ù–æ–≤—ã–π –ø–æ—Ç–æ–∫ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –¥–ª—è: ${currentChannel.name}`);
                  brokenChannels.push(currentChannel.name);
                }
              }
              
              updatedChannels.push(currentChannel);
            }
            
            return {
              channels: updatedChannels,
              updated: updatedCount,
              quality: sourceQuality,
              working: workingChannels,
              broken: brokenChannels
            };
          }

          // –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è M3U –∫–æ–Ω—Ç–µ–Ω—Ç–∞
          function createM3U(channels) {
            let content = '#EXTM3U\n';
            for (const channel of channels) {
              content += `${channel.extinf}\n${channel.url}\n\n`;
            }
            return content;
          }

          // –§—É–Ω–∫—Ü–∏—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –¥–æ–º–µ–Ω–æ–≤ –∏–∑ –∫–∞–Ω–∞–ª–æ–≤
          function extractDomains(channels) {
            const domains = new Set();
            for (const channel of channels) {
              try {
                const url = new URL(channel.url);
                const hostname = url.hostname;
                if (hostname && !hostname.includes('localhost') && !hostname.includes('127.0.0.1')) {
                  domains.add(hostname);
                }
              } catch (e) {
                // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –Ω–µ–≤–∞–ª–∏–¥–Ω—ã–µ URL
              }
            }
            return Array.from(domains);
          }

          // –ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
          async function main() {
            try {
              // –ó–∞–≥—Ä—É–∂–∞–µ–º —Ç–µ–∫—É—â–∏–π —Å–ø–∏—Å–æ–∫ –∫–∞–Ω–∞–ª–æ–≤
              console.log('üì• –ó–∞–≥—Ä—É–∂–∞–µ–º —Ç–µ–∫—É—â–∏–π —Å–ø–∏—Å–æ–∫ –∫–∞–Ω–∞–ª–æ–≤...');
              const currentContent = fs.readFileSync('files/channels.m3u8', 'utf8');
              const currentChannels = parseM3U(currentContent);
              console.log(`üìä –ó–∞–≥—Ä—É–∂–µ–Ω–æ ${currentChannels.length} —Ç–µ–∫—É—â–∏—Ö –∫–∞–Ω–∞–ª–æ–≤`);

              let bestResult = null;
              let usedSource = 'none';

              // –ï—Å–ª–∏ –Ω–µ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ä–µ–∑–µ—Ä–≤, –ø—Ä–æ–±—É–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π –∏—Å—Ç–æ—á–Ω–∏–∫
              if (!FORCE_BACKUP && PRIMARY_URL) {
                try {
                  console.log('\nüéØ –¢–µ—Å—Ç–∏—Ä—É–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π –∏—Å—Ç–æ—á–Ω–∏–∫...');
                  const primaryContent = await fetchContent(PRIMARY_URL);
                  const primaryChannels = parseM3U(primaryContent);
                  
                  const primaryResult = await updateChannels(currentChannels, primaryChannels, '–û—Å–Ω–æ–≤–Ω–æ–π');
                  
                  if (primaryResult.quality >= 0.6) {
                    bestResult = primaryResult;
                    usedSource = 'primary';
                    console.log('‚úÖ –û—Å–Ω–æ–≤–Ω–æ–π –∏—Å—Ç–æ—á–Ω–∏–∫ –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–π, –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ');
                  } else {
                    console.log('‚ö†Ô∏è –û—Å–Ω–æ–≤–Ω–æ–π –∏—Å—Ç–æ—á–Ω–∏–∫ –Ω–∏–∑–∫–æ–≥–æ –∫–∞—á–µ—Å—Ç–≤–∞, –ø–æ–ø—Ä–æ–±—É–µ–º —Ä–µ–∑–µ—Ä–≤–Ω—ã–π');
                  }
                } catch (error) {
                  console.log(`‚ùå –û—à–∏–±–∫–∞ —Å –æ—Å–Ω–æ–≤–Ω—ã–º –∏—Å—Ç–æ—á–Ω–∏–∫–æ–º: ${error.message}`);
                }
              }

              // –ï—Å–ª–∏ –æ—Å–Ω–æ–≤–Ω–æ–π –∏—Å—Ç–æ—á–Ω–∏–∫ –Ω–µ –ø–æ–¥–æ—à–µ–ª, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ä–µ–∑–µ—Ä–≤–Ω—ã–π
              if (!bestResult && BACKUP_URL) {
                try {
                  console.log('\nüîÑ –¢–µ—Å—Ç–∏—Ä—É–µ–º —Ä–µ–∑–µ—Ä–≤–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫...');
                  const backupContent = await fetchContent(BACKUP_URL);
                  const backupChannels = parseM3U(backupContent);
                  
                  const backupResult = await updateChannels(currentChannels, backupChannels, '–†–µ–∑–µ—Ä–≤–Ω—ã–π');
                  
                  if (backupResult.quality >= 0.3) {
                    bestResult = backupResult;
                    usedSource = 'backup';
                    console.log('‚úÖ –†–µ–∑–µ—Ä–≤–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫ –ø—Ä–∏–µ–º–ª–µ–º–æ–≥–æ –∫–∞—á–µ—Å—Ç–≤–∞, –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ');
                  } else {
                    console.log('‚ùå –†–µ–∑–µ—Ä–≤–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫ —Ç–∞–∫–∂–µ –Ω–∏–∑–∫–æ–≥–æ –∫–∞—á–µ—Å—Ç–≤–∞');
                  }
                } catch (error) {
                  console.log(`‚ùå –û—à–∏–±–∫–∞ —Å —Ä–µ–∑–µ—Ä–≤–Ω—ã–º –∏—Å—Ç–æ—á–Ω–∏–∫–æ–º: ${error.message}`);
                }
              }

              // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
              if (bestResult && bestResult.updated > 0) {
                const newContent = createM3U(bestResult.channels);
                fs.writeFileSync('files/channels.m3u8', newContent);
                
                console.log(`\nüéâ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ:`);
                console.log(`üìä –ò—Å—Ç–æ—á–Ω–∏–∫: ${usedSource === 'primary' ? '–û—Å–Ω–æ–≤–Ω–æ–π' : '–†–µ–∑–µ—Ä–≤–Ω—ã–π'}`);
                console.log(`üîÑ –û–±–Ω–æ–≤–ª–µ–Ω–æ –∫–∞–Ω–∞–ª–æ–≤: ${bestResult.updated}`);
                console.log(`‚úÖ –†–∞–±–æ—á–∏—Ö –∫–∞–Ω–∞–ª–æ–≤: ${bestResult.working.length}`);
                console.log(`‚ùå –ü—Ä–æ–±–ª–µ–º–Ω—ã—Ö –∫–∞–Ω–∞–ª–æ–≤: ${bestResult.broken.length}`);
                console.log(`üìà –ö–∞—á–µ—Å—Ç–≤–æ –∏—Å—Ç–æ—á–Ω–∏–∫–∞: ${Math.round(bestResult.quality * 100)}%`);
                
                // –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–æ–º–µ–Ω—ã –¥–ª—è security config
                const domains = extractDomains(bestResult.channels);
                fs.writeFileSync('extracted_domains.txt', domains.join('\n'));
                
                console.log(`üîí –ò–∑–≤–ª–µ—á–µ–Ω–æ –¥–æ–º–µ–Ω–æ–≤: ${domains.length}`);
                console.log(`UPDATED_COUNT=${bestResult.updated}`);
                
                process.exit(0);
              } else {
                console.log('\n‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –ø–æ–¥—Ö–æ–¥—è—â–∏–π –∏—Å—Ç–æ—á–Ω–∏–∫ –∏–ª–∏ –Ω–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π');
                console.log('UPDATED_COUNT=0');
                process.exit(1);
              }
              
            } catch (error) {
              console.error(`‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: ${error.message}`);
              console.log('UPDATED_COUNT=0');
              process.exit(1);
            }
          }

          main();
          EOF

          # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –¥–ª—è —Å–∫—Ä–∏–ø—Ç–∞
          export PRIMARY_URL="${{ github.event.inputs.primary_url }}"
          export BACKUP_URL="${{ github.event.inputs.backup_url }}"
          export FORCE_BACKUP="${{ github.event.inputs.force_backup }}"
          
          # –ó–∞–ø—É—Å–∫–∞–µ–º —É–º–Ω—ã–π —Å–∫—Ä–∏–ø—Ç
          if node smart_update.js > update_output.txt 2>&1; then
            UPDATED_COUNT=$(grep "UPDATED_COUNT=" update_output.txt | cut -d'=' -f2)
            echo "updated_count=${UPDATED_COUNT}" >> $GITHUB_OUTPUT
            echo "has_changes=true" >> $GITHUB_OUTPUT
            cat update_output.txt
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "updated_count=0" >> $GITHUB_OUTPUT
            cat update_output.txt
          fi

      - name: Auto-update security domains
        if: steps.smart-update.outputs.has_changes == 'true'
        run: |
          echo "üîí –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–æ–º–µ–Ω–æ–≤ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏..."
          
          if [ -f "extracted_domains.txt" ]; then
            # –ß–∏—Ç–∞–µ–º –∏–∑–≤–ª–µ—á–µ–Ω–Ω—ã–µ –¥–æ–º–µ–Ω—ã
            NEW_DOMAINS=$(cat extracted_domains.txt)
            echo "üì° –ù–∞–π–¥–µ–Ω–Ω—ã–µ –¥–æ–º–µ–Ω—ã: $NEW_DOMAINS"
            
            # –ß–∏—Ç–∞–µ–º —Ç–µ–∫—É—â–∏–π security config
            CURRENT_XML=$(cat files/security_config.xml)
            
            # –ò–∑–≤–ª–µ–∫–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –¥–æ–º–µ–Ω—ã
            EXISTING_DOMAINS=$(echo "$CURRENT_XML" | grep -o '<domain[^>]*>[^<]*</domain>' | sed 's/<domain[^>]*>//g' | sed 's/<\/domain>//g' | sort | uniq)
            
            # –û–±—ä–µ–¥–∏–Ω—è–µ–º –¥–æ–º–µ–Ω—ã
            ALL_DOMAINS=$(echo -e "$EXISTING_DOMAINS\n$NEW_DOMAINS" | sort | uniq | grep -v "^$")
            
            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã–π security config
            cat > files/security_config.xml << 'SECURITY_EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <network-security-config>
              <domain-config cleartextTrafficPermitted="true">
          SECURITY_EOF
            
            # –î–æ–±–∞–≤–ª—è–µ–º –¥–æ–º–µ–Ω—ã
            echo "$ALL_DOMAINS" | while read domain; do
              if [ ! -z "$domain" ]; then
                echo "        <domain>$domain</domain>" >> files/security_config.xml
              fi
            done
            
            cat >> files/security_config.xml << 'SECURITY_EOF'
              </domain-config>
          </network-security-config>
          SECURITY_EOF
            
            echo "‚úÖ Security config –æ–±–Ω–æ–≤–ª–µ–Ω —Å $(echo "$ALL_DOMAINS" | wc -l) –¥–æ–º–µ–Ω–∞–º–∏"
          else
            echo "‚ö†Ô∏è –§–∞–π–ª extracted_domains.txt –Ω–µ –Ω–∞–π–¥–µ–Ω"
          fi

      - name: Commit changes
        if: steps.smart-update.outputs.has_changes == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "Smart Channel Updater"
          
          # –î–æ–±–∞–≤–ª—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è
          git add files/channels.m3u8 files/security_config.xml
          
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è
          if git diff --staged --quiet; then
            echo "–ù–µ—Ç –∏–∑–º–µ–Ω–µ–Ω–∏–π –¥–ª—è –∫–æ–º–º–∏—Ç–∞"
          else
            UPDATED_COUNT="${{ steps.smart-update.outputs.updated_count }}"
            git commit -m "ü§ñ Smart update: $UPDATED_COUNT channels updated with stream validation

            - –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–±–æ—Ç–æ—Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ –ø–æ—Ç–æ–∫–æ–≤
            - –£–º–Ω–æ–µ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –º–µ–∂–¥—É –∏—Å—Ç–æ—á–Ω–∏–∫–∞–º–∏
            - –ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–æ–º–µ–Ω–æ–≤ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
            - Quality score: –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ $UPDATED_COUNT –∫–∞–Ω–∞–ª–æ–≤"
            git push
            echo "‚úÖ –ò–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π"
          fi

      - name: Cleanup
        run: |
          rm -f smart_update.js update_output.txt extracted_domains.txt
